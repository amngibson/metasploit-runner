require 'metasploit/exploit'

describe 'exploit' do
  before(:each) do
    allow(Metasploit::Exploit).to receive(:sleep)
  end

  describe 'start' do
    before(:each) do
      @expected_connection = 'http://test.connection'
      @expected_token = 'testtoken'
      @expected_port = '3791'
      @expected_uri = '/api/1.1'
      @expected_ssl = false
      @expected_use_os_filter = false
      @expected_no_os_filter = true
      @expected_workspace_name = 'workspacename'
      @expected_nexpose_console_name = 'nexpose_console_name'
      @expected_webscan_task_id = '12'
      @expected_import_task_id = '1'
      @expected_exploit_task_id = '13'
      @expected_audit_task_id = '14'
      @expected_report_id = '15'
      @expected_audit_max_requests = 1000
      @expected_audit_max_minutes = 3
      @expected_audit_max_threads = 5
      @expected_audit_max_instances = 3
      @expected_minimum_rank = 'great'
      @expected_exploit_speed = 5
      @expected_exploit_timeout = 2
      @expected_session_limit = true
      @expected_match_vulns = true
      @expected_match_ports = true
      @expected_ssl_version ='TLS1'
      @expected_report_type = :fisma
      @expected_module_filter = 'exploit/windows/smb/psexec'
      @mock_rpc_client = get_mock_rpc_client
      @mock_device_ip_to_scan = '127.0.0.1'
      @mock_device_url_to_scan = "http://#{@mock_device_ip_to_scan}/"
      @mock_whitelist_hosts = "10.0.0.0/8"

      @options = {
        'connection_url' => @expected_connection,
        'port' => @expected_port,
        'uri' => @expected_uri,
        'use_ssl' => @expected_ssl,
        'token' => @expected_token,
        'workspace_name' => @expected_workspace_name,
        'nexpose_console_name' => @expected_nexpose_console_name,
        'device_ip_to_scan' => @mock_device_ip_to_scan,
        'use_os_filter' => @expected_use_os_filter,
        'module_filter' => @expected_module_filter,
        'report_type' => @expected_report_type,
        'whitelist_hosts' => @mock_whitelist_hosts
      }

      # noinspection RubyStringKeysInHashInspection
      @command_line_arguments = {
          '--connection-url' => 'http://test.connection',
          '--port' => '1234',
          '--token' => 'testtoken',
          '--use-ssl' => nil,
          '--use-os-filter' => nil,
          '--module-filter' => 'exploit/blah1,exploit/blah2',
          '--report-type' => 'fisma',
          '--workspace-name' => 'some-workspace',
          '--nexpose-console-name' => 'some-console',
          '--device-ip-to-scan' => '1.2.3.4',
          '--whitelist-hosts' => '1.2.3.0/24',
          '--exploit-speed' => '200',
      }
    end

    describe 'get connection' do
      it 'should create a session with the metasploit server' do
        expected_options = get_default_options_and_override({})

        expect(Msf::RPC::Client).to receive(:new)
                                    .with(expected_options)
                                    .and_return(@mock_rpc_client)

        Metasploit::Exploit.start(@options)
      end

      it 'should throw an error if no token is passed' do
        options = @options.clone
        options['token'] = nil;
        expect {
          Metasploit::Exploit.start(options)
        }.to raise_error(StandardError, 'PWNED! Token is required')
      end

      it 'should throw an error if no connection url is passed' do
        options = @options.clone
        options['connection_url'] = nil
        expect {
          Metasploit::Exploit.start(options)
        }.to raise_error(StandardError, 'PWNED! Connection URL is required')
      end

      it 'should throw an error if no ip address is passed' do
        options = @options.clone
        options['device_ip_to_scan'] = nil;
        expect {
          Metasploit::Exploit.start(options)
        }.to raise_error(StandardError, 'PWNED! Device IP to scan is required')
      end

      it 'should use 3790 as default if port is empty string' do
        expected_options = get_default_options_and_override({:port => '3790'})

        expect(Msf::RPC::Client).to receive(:new)
                                    .with(expected_options)
                                    .and_return(@mock_rpc_client)

        run_options = @options.clone
        run_options['port'] = nil
        Metasploit::Exploit.start(run_options)
      end
    end

    describe 'create workspace' do
      it 'should create a workspace based on workspace name' do
        expect(@mock_rpc_client).to receive(:call)
                                   .with('pro.workspace_add', {
                                     'name' => @expected_workspace_name
                                   })

        Metasploit::Exploit.start(@options)
      end

      it 'should throw an error if workspace name is invalid' do
        options = @options.clone
        options['workspace_name'] = nil
        expect {
          Metasploit::Exploit.start(options)
        }.to raise_error(StandardError, 'PWNED! Workspace Name is required')
      end
    end

    describe 'should skip nexpose import' do
      it 'should skip the import if nexpose_console variable is empty or nil' do
        options = @options.clone
        options['nexpose_console_name'] = nil
        expect {
          Metasploit::Exploit.start(options)
        }.to output(/\[\*\] Nexpose Console option was not passed, skipping Nexpose Import/).to_stdout
        expect {
          Metasploit::Exploit.start(options)
        }.to_not output(/\[\*\] Importing.../).to_stdout
      end
    end

    describe 'start import from nexpose' do

      it 'should start a import' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_import', {
                                      'workspace' => @expected_workspace_name,
                                      'DS_NEXPOSE_CONSOLE' => @expected_nexpose_console_name,
                                      'DS_NEXPOSE_SITE' => @expected_workspace_name
                                    })

        Metasploit::Exploit.start(@options)
      end

      describe 'wait to be over' do
        before(:each) do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.start_import', {
                                        'workspace' => @expected_workspace_name,
                                        'DS_NEXPOSE_CONSOLE' => @expected_nexpose_console_name,
                                        'DS_NEXPOSE_SITE' => @expected_workspace_name
                                      })
                                      .and_return({'task_id' => @expected_import_task_id})
        end

        it 'should call to check the status of an import' do
          expect(@mock_rpc_client).to receive(:call).with('pro.task_status', @expected_import_task_id)

          Metasploit::Exploit.start(@options)
        end

        it 'should call to check the status until it is not running' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_import_task_id)
                                      .and_return({
                                        '1' => {
                                          'status' => 'running',
                                          'progress' => 25,
                                          'info' => 'Generating the export data file'
                                        }
                                      })
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_import_task_id)
                                      .and_return({
                                        '1' => {
                                          'status' => 'not running',
                                          'progress' => 100,
                                          'info' => 'Complete'
                                        }
                                      })
                                      .once
                                      .ordered

          Metasploit::Exploit.start(@options)
        end

        it 'should sleep for 3 seconds if the status is still running' do
           expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_import_task_id)
                                      .and_return({
                                        '1' => {
                                          'status' => 'running',
                                          'progress' => 25,
                                          'info' => 'Generating the export data file'
                                        }
                                      })
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_import_task_id)
                                      .and_return({
                                        '1' => {
                                          'status' => 'not running',
                                          'progress' => 100,
                                          'info' => 'Complete'
                                        }
                                      })
                                      .once
                                      .ordered
          #Expecting 7 because we are mocking 6 above and the global :call mock in get_mock_rpc_client
          expect(Metasploit::Exploit).to receive(:sleep).with(3).exactly(107).times

          Metasploit::Exploit.start(@options)
        end
      end
    end

    describe 'start metasploit scan' do
      it 'should kick off a scan' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_webscan', {
                                      'workspace' => @expected_workspace_name,
                                      'DS_URLS' => @mock_device_url_to_scan
                                    })

        Metasploit::Exploit.start(@options)
      end

      describe 'wait for scan to be over' do
        before(:each) do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.start_webscan', {
                                        'workspace' => @expected_workspace_name,
                                        'DS_URLS' => @mock_device_url_to_scan
                                      })
                                      .and_return({
                                        'task_id' => @expected_webscan_task_id
                                      })
        end

        it 'should call to check the status of the scan' do
          expect(@mock_rpc_client).to receive(:call).with('pro.task_status', @expected_webscan_task_id)

          Metasploit::Exploit.start(@options)
        end

        it 'should call to check the status until it is not running' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_webscan_task_id)
                                      .and_return({
                                        '12' => {
                                          'status' => 'running',
                                          'progress' => 50,
                                          'info' => 'Validating Target URLs'
                                        }
                                      })
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_webscan_task_id)
                                      .and_return({
                                        '12' => {
                                          'status' => 'not running',
                                          'progress' => 100,
                                          'info' => 'Complete'
                                        }
                                      })
                                      .once
                                      .ordered

          Metasploit::Exploit.start(@options)
        end

        it 'should sleep for 3 seconds if the status is still running' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_webscan_task_id)
                                      .and_return({
                                        '12' => {
                                          'status' => 'running',
                                          'progress' => 50,
                                          'info' => 'Validating Target URLs'
                                        }
                                      })
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_webscan_task_id)
                                      .and_return({
                                         '12' => {
                                           'status' => 'not running',
                                           'progress' => 100,
                                           'info' => 'Complete'
                                         }
                                      })
                                      .once
                                      .ordered

          #Expecting 7 because we are mocking 6 above and the global :call mock in get_mock_rpc_client
          expect(Metasploit::Exploit).to receive(:sleep).with(3).exactly(107).times

          Metasploit::Exploit.start(@options)
        end
      end
    end

    describe 'start generating report' do
      it 'should start a report' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_report', {
                                     'workspace' => @expected_workspace_name,
                                     'name' => @expected_workspace_name,
                                     'report_type' => @expected_report_type,
                                     'created_by' => @expected_workspace_name,
                                     'file_formats' => [:pdf],
                                     'DS_WHITELIST_HOSTS' => @mock_device_url_to_scan,
                                    })

        Metasploit::Exploit.start(@options)
      end

      it 'should skip report if report_type not specified' do
        expect(@mock_rpc_client).to_not receive(:call).with('pro.start_report', anything)

        @options['report_type'] = ''
        @options['report_type'] = nil
        Metasploit::Exploit.start(@options)

        @command_line_arguments.delete '--report-type'
        Metasploit::Exploit.start(hash_to_array(@command_line_arguments))
      end
    end

    describe 'start an audit' do

      it 'should kick off an audit' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_webaudit', {
                                      'workspace' => @expected_workspace_name,
                                      'DS_URLS' => @mock_device_url_to_scan,
                                      'DS_MAX_REQUESTS' => @expected_audit_max_requests,
                                      'DS_MAX_MINUTES' => @expected_audit_max_minutes,
                                      'DS_MAX_THREADS' => @expected_audit_max_threads,
                                      'DS_MAX_INSTANCES' => @expected_audit_max_instances
                                    })

       Metasploit::Exploit.start(@options)
      end

      describe 'wait for audit to be over' do
        before(:each) do

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.start_webaudit', {
                                        "workspace" => @expected_workspace_name,
                                        "DS_URLS" => @mock_device_url_to_scan,
                                        "DS_MAX_REQUESTS" => @expected_audit_max_requests,
                                        "DS_MAX_MINUTES" => @expected_audit_max_minutes,
                                        "DS_MAX_THREADS" => @expected_audit_max_threads,
                                        "DS_MAX_INSTANCES" => @expected_audit_max_instances
                                      })
                                      .and_return({'task_id' => @expected_audit_task_id})
        end

        it 'should call to check the status of the audit' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_audit_task_id)

          Metasploit::Exploit.start(@options)
        end

        it 'should call to check the status until it is not running' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_audit_task_id)
                                      .and_return({
                                        '14' => {
                                          'status' => 'running',
                                          'progress' => 3,
                                          'info' => 'Auditing your website'
                                        }
                                      })
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_audit_task_id)
                                      .and_return({
                                        '14' => {
                                          'status' => 'not running',
                                          'progress' => 100,
                                          'info' => 'Complete'
                                        }
                                      })
                                      .once
                                      .ordered

          Metasploit::Exploit.start(@options)
        end

        it 'should sleep for 3 seconds if the status is still running' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_audit_task_id)
                                      .and_return({
                                        '14' => {
                                          'status' => 'running',
                                          'progress' => 3,
                                          'info' => 'Auditing your website'
                                        }
                                      })
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_audit_task_id)
                                      .and_return({
                                        '14' => {
                                          'status' => 'not running',
                                          'progress' => 100,
                                          'info' => 'Complete'
                                        }
                                      })
                                      .once
                                      .ordered

          expect(Metasploit::Exploit).to receive(:sleep)
                                         .with(3)
                                         .exactly(107)
                                         .times

          Metasploit::Exploit.start(@options)
        end
      end
    end

    describe 'start a exploit' do

      it 'should kick off an exploit' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_exploit', {
                                      "workspace" => @expected_workspace_name,
                                      "DS_WHITELIST_HOSTS" => @mock_whitelist_hosts,
                                      "DS_MinimumRank" => @expected_minimum_rank,
                                      "DS_EXPLOIT_SPEED" => @expected_exploit_speed,
                                      "DS_EXPLOIT_TIMEOUT" => @expected_exploit_timeout,
                                      "DS_LimitSessions" => @expected_session_limit,
                                      "DS_MATCH_VULNS" => @expected_match_vulns,
                                      "DS_MATCH_PORTS" => @expected_match_ports,
                                      "DS_FilterByOS" =>  @expected_use_os_filter,
                                      "DS_ModuleFilter" => @expected_module_filter
                                     })

        Metasploit::Exploit.start(@options)
      end

      it 'should use a operating system filter if its set to true' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_exploit', {
                                      "workspace" => @expected_workspace_name,
                                      "DS_WHITELIST_HOSTS" => @mock_whitelist_hosts,
                                      "DS_MinimumRank" => @expected_minimum_rank,
                                      "DS_EXPLOIT_SPEED" => @expected_exploit_speed,
                                      "DS_EXPLOIT_TIMEOUT" => @expected_exploit_timeout,
                                      "DS_LimitSessions" => @expected_session_limit,
                                      "DS_MATCH_VULNS" => @expected_match_vulns,
                                      "DS_MATCH_PORTS" => @expected_match_ports,
                                      "DS_FilterByOS" =>  @expected_use_os_filter,
                                      "DS_ModuleFilter" => @expected_module_filter
                                      })

        Metasploit::Exploit.start(@options)
      end

      it 'should not use a operating system filter if its set to false' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_exploit', {
                                      "workspace" => @expected_workspace_name,
                                      "DS_WHITELIST_HOSTS" => @mock_whitelist_hosts,
                                      "DS_MinimumRank" => @expected_minimum_rank,
                                      "DS_EXPLOIT_SPEED" => @expected_exploit_speed,
                                      "DS_EXPLOIT_TIMEOUT" => @expected_exploit_timeout,
                                      "DS_LimitSessions" => @expected_session_limit,
                                      "DS_MATCH_VULNS" => @expected_match_vulns,
                                      "DS_MATCH_PORTS" => @expected_match_ports,
                                      "DS_FilterByOS" =>  false,
                                      "DS_ModuleFilter" => @expected_module_filter
                                    })

        options = @options.clone
        options['use_os_filter'] = false
        Metasploit::Exploit.start(options)
      end

      it 'should not use a module filter if no modules are passed' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_exploit', {
                                      "workspace" => @expected_workspace_name,
                                      "DS_WHITELIST_HOSTS" => @mock_whitelist_hosts,
                                      "DS_MinimumRank" => @expected_minimum_rank,
                                      "DS_EXPLOIT_SPEED" => @expected_exploit_speed,
                                      "DS_EXPLOIT_TIMEOUT" => @expected_exploit_timeout,
                                      "DS_LimitSessions" => @expected_session_limit,
                                      "DS_MATCH_VULNS" => @expected_match_vulns,
                                      "DS_MATCH_PORTS" => @expected_match_ports,
                                      "DS_FilterByOS" =>  false,
                                      "DS_ModuleFilter" => nil
                                    })

        options = @options.clone
        options['module_filter'] = nil
        options['use_os_filter'] = false
        Metasploit::Exploit.start(options)
      end

      it 'should use a module filter if a module is passed' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_exploit', {
                                      "workspace" => @expected_workspace_name,
                                      "DS_WHITELIST_HOSTS" => @mock_whitelist_hosts,
                                      "DS_MinimumRank" => @expected_minimum_rank,
                                      "DS_EXPLOIT_SPEED" => @expected_exploit_speed,
                                      "DS_EXPLOIT_TIMEOUT" => @expected_exploit_timeout,
                                      "DS_LimitSessions" => @expected_session_limit,
                                      "DS_MATCH_VULNS" => @expected_match_vulns,
                                      "DS_MATCH_PORTS" => @expected_match_ports,
                                      "DS_FilterByOS" =>  false,
                                      "DS_ModuleFilter" => @expected_module_filter
                                    })
        options = @options.clone
        options['use_os_filter'] = false
        Metasploit::Exploit.start(options)
      end

      it 'should set configuration properties based on command-line arguments' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_exploit', {
                                      "workspace" => @command_line_arguments['--workspace-name'],
                                      "DS_WHITELIST_HOSTS" => @command_line_arguments['--whitelist-hosts'],
                                      "DS_MinimumRank" => 'great',
                                      "DS_EXPLOIT_SPEED" => @command_line_arguments['--exploit-speed'],
                                      "DS_EXPLOIT_TIMEOUT" => 2,
                                      "DS_LimitSessions" => false,
                                      "DS_MATCH_VULNS" => true,
                                      "DS_MATCH_PORTS" => true,
                                      "DS_FilterByOS" => true,
                                      "DS_ModuleFilter" => @command_line_arguments['--module-filter']
                                    })

        Metasploit::Exploit.start(hash_to_array(@command_line_arguments))
      end

      describe 'wait for exploit to be over' do
        before(:each) do

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.start_exploit', {
                                        "workspace" => @expected_workspace_name,
                                        "DS_WHITELIST_HOSTS" => @mock_whitelist_hosts,
                                        "DS_MinimumRank" => @expected_minimum_rank,
                                        "DS_EXPLOIT_SPEED" => @expected_exploit_speed,
                                        "DS_EXPLOIT_TIMEOUT" => @expected_exploit_timeout,
                                        "DS_LimitSessions" => @expected_session_limit,
                                        "DS_MATCH_VULNS" => @expected_match_vulns,
                                        "DS_MATCH_PORTS" => @expected_match_ports,
                                        "DS_FilterByOS" =>  @expected_use_os_filter,
                                        "DS_ModuleFilter" => @expected_module_filter
                                      })
                                      .and_return({
                                        'task_id' => @expected_exploit_task_id
                                      })
        end

        it 'should call to check the status of the exploit' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_exploit_task_id)

          Metasploit::Exploit.start(@options)
        end

        it 'should call to check the status until it is not running' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_exploit_task_id)
                                      .and_return({
                                        '13' => {
                                          'status' => 'running',
                                          'progress' => 3,
                                          'info' => 'WordPress Asset-Manager PHP File Upload Vulnerability'
                                        }
                                      })
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_exploit_task_id)
                                      .and_return({
                                        '13' => {
                                          'status' => 'not running',
                                          'progress' => 100,
                                          'info' => 'Complete'
                                        }
                                      })
                                      .once
                                      .ordered

          Metasploit::Exploit.start(@options)
        end

        it 'should sleep for 3 seconds if the status is still running' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_exploit_task_id)
                                      .and_return({
                                        '13' => {
                                          'status' => 'running',
                                          'progress' => 3,
                                          'info' => 'WordPress Asset-Manager PHP File Upload Vulnerability'
                                        }
                                      })
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_exploit_task_id)
                                      .and_return({
                                        '13' => {
                                          'status' => 'not running',
                                          'progress' => 100,
                                          'info' => 'Complete'
                                        }
                                      })
                                      .once
                                      .ordered

          expect(Metasploit::Exploit).to receive(:sleep)
                                         .with(3)
                                         .exactly(107)
                                         .times

          Metasploit::Exploit.start(@options)
        end
      end
    end

  end
end

def get_default_options_and_override(override)
  {
    :host => @expected_connection,
    :port => @expected_port,
    :token => @expected_token,
    :uri => @expected_uri,
    :ssl => @expected_ssl,
    :ssl_version => @expected_ssl_version
  }.merge(override)
end

def get_mock_rpc_client
  mock_rpc_client = double(Msf::RPC::Client)

  allow(mock_rpc_client).to receive(:call)
                            .with(any_args)
                            .and_return({})

  allow(Msf::RPC::Client).to receive(:new)
                             .and_return(mock_rpc_client)

  mock_rpc_client
end

def hash_to_array(hash)
  hash.map { |key, value| [key, value] }.flatten.select { |val| !val.nil? }
end

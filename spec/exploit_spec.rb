require 'metasploit/exploit'

describe 'exploit' do
  before(:each) do
    allow(Metasploit::Exploit).to receive(:sleep)
  end

  describe 'start' do
    before(:each) do
      @expected_connection = 'http://test.connection'
      @expected_token = 'testtoken'
      @expected_port = '3791'
      @expected_uri = '/api/1.1'
      @expected_ssl = false
      @expected_use_os_filter = true
      @expected_workspace_name = 'workspacename'
      @expected_nexpose_console_name = 'nexpose_console_name'
      @expected_webscan_task_id = '12'
      @expected_import_task_id = '1'
      @expected_exploit_task_id = '13'
      @expected_audit_task_id = '14'
      @expected_audit_max_requests = 1000
      @expected_audit_max_minutes = 3
      @expected_audit_max_threads = 5
      @expected_audit_max_instances = 3
      @mock_rpc_client = get_mock_rpc_client
      @mock_device_ip_to_scan = '127.0.0.1'
      @mock_device_url_to_scan = "http://#{@mock_device_ip_to_scan}"
    end

    describe 'get connection' do
      it 'should create a session with the metasploit server' do
        expected_options = get_default_options_and_override({})

        expect(Msf::RPC::Client).to receive(:new)
                                    .with(expected_options)
                                    .and_return(@mock_rpc_client)

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
      end

      it 'should throw an error if no token is passed' do
        expect { Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, '', @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter) }.to raise_error(StandardError, 'PWNED! Token is required')
        expect { Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, nil, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter) }.to raise_error(StandardError, 'PWNED! Token is required')
      end

      it 'should throw an error if no connection url is passed' do
        expect { Metasploit::Exploit.start('', @expected_port, @expected_uri, @expected_ssl, @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter) }.to raise_error(StandardError, 'PWNED! Connection URL is required')
        expect { Metasploit::Exploit.start(nil, @expected_port, @expected_uri, @expected_ssl, @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter) }.to raise_error(StandardError, 'PWNED! Connection URL is required')
      end

      it 'should throw an error if no ip address is passed' do
        expect { Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, @expected_token, @expected_workspace_name, @expected_nexpose_console_name, '', @expected_use_os_filter) }.to raise_error(StandardError, 'PWNED! Device IP to scan is required')
        expect { Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, @expected_token, @expected_workspace_name, @expected_nexpose_console_name, nil, @expected_use_os_filter) }.to raise_error(StandardError, 'PWNED! Device IP to scan is required')
      end

      it 'should use 3790 as default if port is empty string' do
        expected_options = get_default_options_and_override({:port => '3790'})

        expect(Msf::RPC::Client).to receive(:new)
                                    .with(expected_options)
                                    .and_return(@mock_rpc_client)

        Metasploit::Exploit.start(@expected_connection, '', @expected_uri, @expected_ssl, @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
      end
    end

    describe 'create workspace' do
      it 'should create a workspace based on workspace name' do
        expect(@mock_rpc_client).to receive(:call)
                                   .with('pro.workspace_add', {'name' => @expected_workspace_name})

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
      end

      it 'should throw an error if workspace name is invalid' do
        expect { Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, @expected_token, '', @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter) }.to raise_error(StandardError, 'PWNED! Workspace Name is required')
        expect { Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, @expected_token, nil, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter) }.to raise_error(StandardError, 'PWNED! Workspace Name is required')
      end
    end

    describe 'should skip nexpose import' do
      it 'should skip the import if nexpose_console variable is empty or nil' do
        expect {Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, @expected_token, @expected_workspace_name, '', @mock_device_ip_to_scan, @expected_use_os_filter)}.to output(/\[\*\] Nexpose Console option was not passed, skipping Nexpose Import/).to_stdout
        expect {Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, @expected_token, @expected_workspace_name, nil, @mock_device_ip_to_scan, @expected_use_os_filter)}.to output(/\[\*\] Nexpose Console option was not passed, skipping Nexpose Import/).to_stdout
        expect {Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, @expected_token, @expected_workspace_name, '', @mock_device_ip_to_scan, @expected_use_os_filter)}.to_not output(/\[\*\] Importing.../).to_stdout
        expect {Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, @expected_token, @expected_workspace_name, nil, @mock_device_ip_to_scan, @expected_use_os_filter)}.to_not output(/\[\*\] Importing...'/).to_stdout
      end
    end

    describe 'start import from nexpose' do

      it 'should start a import' do
        expect(@mock_rpc_client).to receive(:call)
                                  .with('pro.start_import', {'workspace' => @expected_workspace_name,
                                                             'DS_NEXPOSE_CONSOLE' => @expected_nexpose_console_name,
                                                             'DS_NEXPOSE_SITE' => @expected_workspace_name})

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
      end

      describe 'wait to be over' do
        before(:each) do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.start_import', {'workspace' => @expected_workspace_name,
                                                                 'DS_NEXPOSE_CONSOLE' => @expected_nexpose_console_name,
                                                                 'DS_NEXPOSE_SITE' => @expected_workspace_name})
                                      .and_return({'task_id' => @expected_import_task_id})
        end

        it 'should call to check the status of an import' do
          expect(@mock_rpc_client).to receive(:call).with('pro.task_status', @expected_import_task_id)

          Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
        end

        it 'should call to check the status until it is not running' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_import_task_id)
                                      .and_return({'1'=>{'status' => 'running', 'progress' => 25, 'info' => 'Generating the export data file'}})
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_import_task_id)
                                      .and_return({'1'=>{'status' => 'not running', 'progress' => 100, 'info' => 'Complete'}})
                                      .once
                                      .ordered

          Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
        end

        it 'should sleep for 3 seconds if the status is still running' do
           expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_import_task_id)
                                      .and_return({'1'=>{'status' => 'running', 'progress' => 25, 'info' => 'Generating the export data file'}})
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_import_task_id)
                                      .and_return({'1'=>{'status' => 'not running', 'progress' => 100, 'info' => 'Complete'}})
                                      .once
                                      .ordered

          #Expecting 7 because we are mocking 6 above and the global :call mock in get_mock_rpc_client
          expect(Metasploit::Exploit).to receive(:sleep).with(3).exactly(7).times

          Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
        end
      end
    end

    describe 'start metasploit scan' do
      it 'should kick off a scan' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_webscan', {'workspace' => @expected_workspace_name,
                                                                'DS_URLS' => @mock_device_url_to_scan})

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
      end

      describe 'wait for scan to be over' do
        before(:each) do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.start_webscan', {'workspace' => @expected_workspace_name,
                                                                  'DS_URLS' => @mock_device_url_to_scan})
                                      .and_return({'task_id' => @expected_webscan_task_id})
        end

        it 'should call to check the status of the scan' do
          expect(@mock_rpc_client).to receive(:call).with('pro.task_status', @expected_webscan_task_id)

          Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
        end

        it 'should call to check the status until it is not running' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_webscan_task_id)
                                      .and_return({'12'=>{'status' => 'running', 'progress' => 50, 'info' => 'Validating Target URLs'}})
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_webscan_task_id)
                                      .and_return({'12'=>{'status' => 'not running', 'progress' => 100, 'info' => 'Complete'}})
                                      .once
                                      .ordered

          Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
        end

        it 'should sleep for 3 seconds if the status is still running' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_webscan_task_id)
                                      .and_return({'12'=>{'status' => 'running', 'progress' => 50, 'info' => 'Validating Target URLs'}})
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_webscan_task_id)
                                      .and_return({'12'=>{'status' => 'not running', 'progress' => 100, 'info' => 'Complete'}})
                                      .once
                                      .ordered

          #Expecting 7 because we are mocking 6 above and the global :call mock in get_mock_rpc_client
          expect(Metasploit::Exploit).to receive(:sleep).with(3).exactly(7).times

          Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
        end
      end
    end

    describe 'start an audit' do

      it 'should kick off an audit' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_webaudit', {
                                                                  'workspace' => @expected_workspace_name,
                                                                  'DS_URLS' => @mock_device_url_to_scan,
                                                                  'DS_MAX_REQUESTS' => @expected_audit_max_requests,
                                                                  'DS_MAX_MINUTES' => @expected_audit_max_minutes,
                                                                  'DS_MAX_THREADS' => @expected_audit_max_threads,
                                                                  'DS_MAX_INSTANCES' => @expected_audit_max_instances
                                                                })

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
      end

      describe 'wait for audit to be over' do
        before(:each) do

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.start_webaudit', {
                                                                    'workspace' => @expected_workspace_name,
                                                                    'DS_URLS' => @mock_device_url_to_scan,
                                                                    'DS_MAX_REQUESTS' => @expected_audit_max_requests,
                                                                    'DS_MAX_MINUTES' => @expected_audit_max_minutes,
                                                                    'DS_MAX_THREADS' => @expected_audit_max_threads,
                                                                    'DS_MAX_INSTANCES' => @expected_audit_max_instances
                                                                  })
                                      .and_return({'task_id' => @expected_audit_task_id})
        end

        it 'should call to check the status of the audit' do
          expect(@mock_rpc_client).to receive(:call).with('pro.task_status', @expected_audit_task_id)

          Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
        end

        it 'should call to check the status until it is not running' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_audit_task_id)
                                      .and_return({'14'=>{'status' => 'running', 'progress' => 3, 'info' => 'Auditing your website'}})
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_audit_task_id)
                                      .and_return({'14'=>{'status' => 'not running', 'progress' => 100, 'info' => 'Complete'}})
                                      .once
                                      .ordered

          Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
        end

        it 'should sleep for 3 seconds if the status is still running' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_audit_task_id)
                                      .and_return({'14'=>{'status' => 'running', 'progress' => 3, 'info' => 'Auditing your website'}})
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_audit_task_id)
                                      .and_return({'14'=>{'status' => 'not running', 'progress' => 100, 'info' => 'Complete'}})
                                      .once
                                      .ordered

          #Expecting 7 because we are mocking 6 above and the global :call mock in get_mock_rpc_client
          expect(Metasploit::Exploit).to receive(:sleep).with(3).exactly(7).times

          Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
        end
      end
    end

    describe 'start a exploit' do

      it 'should kick off an exploit' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_exploit', {'workspace' => @expected_workspace_name, 'DS_FilterByOS' => @expected_use_os_filter})

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
      end

      it 'should use a operating system filter if its set to true' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_exploit', {'workspace' => @expected_workspace_name, 'DS_FilterByOS' => @expected_use_os_filter})

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
      end

      describe 'wait for exploit to be over' do
        before(:each) do

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.start_exploit', {'workspace' => @expected_workspace_name, 'DS_FilterByOS' => @expected_use_os_filter})
                                      .and_return({'task_id' => @expected_exploit_task_id})
        end

        it 'should call to check the status of the exploit' do
          expect(@mock_rpc_client).to receive(:call).with('pro.task_status', @expected_exploit_task_id)

          Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
        end

        it 'should call to check the status until it is not running' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_exploit_task_id)
                                      .and_return({'13'=>{'status' => 'running', 'progress' => 3, 'info' => 'WordPress Asset-Manager PHP File Upload Vulnerability'}})
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_exploit_task_id)
                                      .and_return({'13'=>{'status' => 'not running', 'progress' => 100, 'info' => 'Complete'}})
                                      .once
                                      .ordered

          Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
        end

        it 'should sleep for 3 seconds if the status is still running' do
          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_exploit_task_id)
                                      .and_return({'13'=>{'status' => 'running', 'progress' => 3, 'info' => 'WordPress Asset-Manager PHP File Upload Vulnerability'}})
                                      .exactly(3).times
                                      .ordered

          expect(@mock_rpc_client).to receive(:call)
                                      .with('pro.task_status', @expected_exploit_task_id)
                                      .and_return({'13'=>{'status' => 'not running', 'progress' => 100, 'info' => 'Complete'}})
                                      .once
                                      .ordered

          #Expecting 7 because we are mocking 6 above and the global :call mock in get_mock_rpc_client
          expect(Metasploit::Exploit).to receive(:sleep).with(3).exactly(7).times

          Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name, @mock_device_ip_to_scan, @expected_use_os_filter)
        end
      end
    end

    
  end
end

def get_default_options_and_override(override)
  {:host => @expected_connection, :port => @expected_port, :token => @expected_token, :uri => @expected_uri, :ssl => @expected_ssl}.merge(override)
end

def get_mock_rpc_client
  mock_rpc_client = double(Msf::RPC::Client)

  allow(mock_rpc_client).to receive(:call).with(any_args).and_return({})

  allow(Msf::RPC::Client).to receive(:new)
                             .and_return(mock_rpc_client)

  mock_rpc_client
end

require 'metasploit/exploit'

describe 'exploit' do
  before(:each) do
    allow(Metasploit::Exploit).to receive(:sleep)
  end

  describe 'start' do
    before(:each) do
      @expected_connection = 'http://test.connection'
      @expected_token = 'testtoken'
      @expected_port = '3791'
      @expected_uri = '/api/1.1'
      @expected_ssl = false
      @expected_workspace_name = 'workspacename'
      @expected_nexpose_console_name = 'nexpose_console_name'
      @mock_rpc_client = get_mock_rpc_client
    end

    describe 'get connection' do
      it 'should create a session with the metasploit server' do
        expected_options = get_default_options_and_override({})

        expect(Msf::RPC::Client).to receive(:new)
                                    .with(expected_options)
                                    .and_return(@mock_rpc_client)

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, @expected_token, @expected_workspace_name, '')
      end

      it 'should throw an error if no token is passed' do
        expect { Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, '', @expected_workspace_name, '') }.to raise_error(StandardError, 'PWNED! Token is required')
        expect { Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, nil, @expected_workspace_name, '') }.to raise_error(StandardError, 'PWNED! Token is required')
      end

      it 'should throw an error if no connection url is passed' do
        expect { Metasploit::Exploit.start('', @expected_port, @expected_uri, @expected_ssl, @expected_token, @expected_workspace_name, '') }.to raise_error(StandardError, 'PWNED! Connection URL is required')
        expect { Metasploit::Exploit.start(nil, @expected_port, @expected_uri, @expected_ssl, @expected_token, @expected_workspace_name, '') }.to raise_error(StandardError, 'PWNED! Connection URL is required')
      end

      it 'should use 3790 as default if port is empty string' do
        expected_options = get_default_options_and_override({:port => '3790'})

        expect(Msf::RPC::Client).to receive(:new)
                                    .with(expected_options)
                                    .and_return(@mock_rpc_client)

        Metasploit::Exploit.start(@expected_connection, '', @expected_uri, @expected_ssl, @expected_token, @expected_workspace_name, '')
      end

      it 'should use 3790 as default if port is nil' do
        expected_options = get_default_options_and_override({:port => '3790'})

        expect(Msf::RPC::Client).to receive(:new)
                                    .with(expected_options)
                                    .and_return(@mock_rpc_client)

        Metasploit::Exploit.start(@expected_connection, nil, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, '')
      end

      it 'should use /api/1.0 as default if no uri is passed' do
        expected_options = get_default_options_and_override({:uri => '/api/1.0'})

        expect(Msf::RPC::Client).to receive(:new)
                                    .with(expected_options)
                                    .and_return(@mock_rpc_client)

        Metasploit::Exploit.start(@expected_connection, @expected_port, '', @expected_ssl,  @expected_token, @expected_workspace_name, '')
      end

      it 'should use /api/1.0 as default if no uri is passed' do
        expected_options = get_default_options_and_override({:uri => '/api/1.0'})

        expect(Msf::RPC::Client).to receive(:new)
                                    .with(expected_options)
                                    .and_return(@mock_rpc_client)

        Metasploit::Exploit.start(@expected_connection, @expected_port, nil, @expected_ssl,  @expected_token, @expected_workspace_name, '')
      end

      it 'should use ssl true as default if empty string is passed' do
        expected_options = get_default_options_and_override({:ssl => true})

        expect(Msf::RPC::Client).to receive(:new)
                                    .with(expected_options)
                                    .and_return(@mock_rpc_client)

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, '',  @expected_token, @expected_workspace_name, '')
      end

      it 'should use ssl true as default if random string is passed' do
        expected_options = get_default_options_and_override({:ssl => true})

        expect(Msf::RPC::Client).to receive(:new)
                                    .with(expected_options)
                                    .and_return(@mock_rpc_client)

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, 'sadf',  @expected_token, @expected_workspace_name, '')
      end

      it 'should use ssl true as default if nil is passed' do
        expected_options = get_default_options_and_override({:ssl => true})

        expect(Msf::RPC::Client).to receive(:new)
                                    .with(expected_options)
                                    .and_return(@mock_rpc_client)

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, nil,  @expected_token, @expected_workspace_name, '')
      end

      it 'should use ssl true as default if true is passed' do
        expected_options = get_default_options_and_override({:ssl => true})

        expect(Msf::RPC::Client).to receive(:new)
                                    .with(expected_options)
                                    .and_return(@mock_rpc_client)

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, true,  @expected_token, @expected_workspace_name, '')
      end
    end

    describe 'create workspace' do
      it 'should create a workspace based on workspace name' do
        expect(@mock_rpc_client).to receive(:call)
                                   .with('pro.workspace_add', {'name' => @expected_workspace_name})

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, '')
      end

      it 'should throw an error if workspace name is invalid' do
        expect { Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, @expected_token, '', '') }.to raise_error(StandardError, 'PWNED! Workspace Name is required')
        expect { Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl, @expected_token, nil, '') }.to raise_error(StandardError, 'PWNED! Workspace Name is required')
      end
    end

    describe 'start import from nexpose' do
      it 'should start a import' do
        expect(@mock_rpc_client).to receive(:call)
                                  .with('pro.start_import', {'workspace' => @expected_workspace_name,
                                                             'DS_NEXPOSE_CONSOLE' => @expected_nexpose_console_name,
                                                             'DS_NEXPOSE_SITE' => @expected_workspace_name})

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name)
      end
    end

    describe 'wait until metasploit finishes' do
      before(:each) do
        @expected_task_id = '1'
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.start_import', {'workspace' => @expected_workspace_name,
                                                               'DS_NEXPOSE_CONSOLE' => @expected_nexpose_console_name,
                                                               'DS_NEXPOSE_SITE' => @expected_workspace_name})
                                    .and_return({'task_id' => @expected_task_id})
      end

      it 'should call to check the status of an import' do
        expect(@mock_rpc_client).to receive(:call).with('pro.task_status', @expected_task_id)

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name)
      end

      it 'should call to check the status until it is not running' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.task_status', @expected_task_id)
                                    .and_return({'status' => 'running'})
                                    .exactly(3).times
                                    .ordered

        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.task_status', @expected_task_id)
                                    .and_return({'status' => 'not running'})
                                    .once
                                    .ordered

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name)
      end

      it 'should sleep for 3 seconds if the status is still running' do
        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.task_status', @expected_task_id)
                                    .and_return({'status' => 'running'})
                                    .exactly(3).times
                                    .ordered

        expect(@mock_rpc_client).to receive(:call)
                                    .with('pro.task_status', @expected_task_id)
                                    .and_return({'status' => 'not running'})
                                    .once
                                    .ordered

        expect(Metasploit::Exploit).to receive(:sleep).with(3).exactly(4).times

        Metasploit::Exploit.start(@expected_connection, @expected_port, @expected_uri, @expected_ssl,  @expected_token, @expected_workspace_name, @expected_nexpose_console_name)
      end
    end
  end
end

def get_default_options_and_override(override)
  {:host => @expected_connection, :port => @expected_port, :token => @expected_token, :uri => @expected_uri, :ssl => @expected_ssl}.merge(override)
end

def get_mock_rpc_client
  mock_rpc_client = double(Msf::RPC::Client)

  allow(mock_rpc_client).to receive(:call).with(any_args).and_return({})

  allow(Msf::RPC::Client).to receive(:new)
                             .and_return(mock_rpc_client)

  mock_rpc_client
end